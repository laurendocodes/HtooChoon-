import 'package:flutter/material.dart';
import '../models/form_model.dart';
import '../models/question_model.dart';
import '../services/form_service.dart';
import 'package:uuid/uuid.dart';

class FormBuilderProvider extends ChangeNotifier {
  final FormService _formService = FormService();
  final Uuid _uuid = const Uuid();

  FormModel? _currentForm;
  bool _isLoading = false;

  FormModel? get currentForm => _currentForm;
  bool get isLoading => _isLoading;

  // Initialize a new form or edit existing one
  void initForm(String? formId, String userId) async {
    _isLoading = true;
    notifyListeners();

    if (formId != null) {
      _currentForm = await _formService.getForm(formId);
    } else {
      _currentForm = FormModel(
        id: '', // Will be generated by Firestore
        title: '',
        description: '',
        createdBy: userId,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        questions: [],
      );
    }
    _isLoading = false;
    notifyListeners();
  }

  void updateMetadata({
    String? title,
    String? description,
    FormType? type,
    int? timeLimit,
    String? classId,
    String? courseId,
  }) {
    if (_currentForm != null) {
      _currentForm = FormModel(
        id: _currentForm!.id,
        title: title ?? _currentForm!.title,
        description: description ?? _currentForm!.description,
        type: type ?? _currentForm!.type,
        createdBy: _currentForm!.createdBy,
        classId: classId ?? _currentForm!.classId,
        courseId: courseId ?? _currentForm!.courseId,
        questions: _currentForm!.questions,
        timeLimit: timeLimit ?? _currentForm!.timeLimit,
        totalMarks: _currentForm!.totalMarks,
        isPublished: _currentForm!.isPublished,
        createdAt: _currentForm!.createdAt,
        updatedAt: DateTime.now(),
      );
      notifyListeners();
    }
  }

  void addQuestion(QuestionType type) {
    if (_currentForm != null) {
      List<String> options = [];
      if (type == QuestionType.multipleChoice || type == QuestionType.checkbox) {
        options = ['Option 1'];
      } else if (type == QuestionType.trueFalse) {
        options = ['True', 'False'];
      }
      
      final newQuestion = QuestionModel(
        id: _uuid.v4(),
        type: type,
        questionText: '',
        options: options,
        marks: 1,
      );
      _currentForm!.questions.add(newQuestion);
      _updateTotalMarks();
      notifyListeners();
    }
  }

  void updateQuestion(String id, QuestionModel newQuestion) {
    if (_currentForm != null) {
      final index = _currentForm!.questions.indexWhere((q) => q.id == id);
      if (index != -1) {
        _currentForm!.questions[index] = newQuestion;
        _updateTotalMarks();
        notifyListeners();
      }
    }
  }

  void deleteQuestion(String id) {
    if (_currentForm != null) {
      _currentForm!.questions.removeWhere((q) => q.id == id);
      _updateTotalMarks();
      notifyListeners();
    }
  }

  void reorderQuestions(int oldIndex, int newIndex) {
    if (_currentForm != null) {
      if (newIndex > oldIndex) newIndex -= 1;
      final QuestionModel item = _currentForm!.questions.removeAt(oldIndex);
      _currentForm!.questions.insert(newIndex, item);
      notifyListeners();
    }
  }

  void _updateTotalMarks() {
    if (_currentForm != null) {
      int total = 0;
      for (var q in _currentForm!.questions) {
        total += q.marks;
      }
      _currentForm!.totalMarks = total;
    }
  }

  Future<void> saveForm() async {
    if (_currentForm != null) {
      _isLoading = true;
      notifyListeners();
      await _formService.saveForm(_currentForm!);
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> publishForm() async {
    if (_currentForm != null) {
      _currentForm!.isPublished = true;
      await saveForm();
    }
  }
}
